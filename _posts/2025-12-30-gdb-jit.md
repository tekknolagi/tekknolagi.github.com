---
title: "The GDB JIT interface"
layout: post
---

GDB is great for stepping through machine code to figure out what is going on.
It uses debug information under the hood to present you with a tidy backtrace
and also determine how much machine code to print when you type `disassemble`.

This debug information comes from your compiler. Clang, GCC, rustc, etc all
produce debug data in a format called [DWARF][] and then embed that debug
information inside the binary (ELF, Mach-O, ...).

[DWARF]: https://dwarfstd.org/

Unfortunately, this means that by default, GDB has no idea what is going on if
you break in a JIT-compiled function. The current instruction pointer is
nowhere to be found in any of the existing debug info tables, so your terminal
is filled with `???`.

Fortunately, there is a *JIT interface* to GDB. If you implement a couple of
functions in your JIT and run them every time you finish compiling a function,
you can get the debugging niceties for your JIT code too.

Unfortunately, the docs are [somewhat sparse][gdb-docs]. So I went spelunking
through a bunch of different projects to try and understand what is going on.

[gdb-docs]: https://sourceware.org/gdb/current/onlinedocs/gdb.html/JIT-Interface.html

## The big picture

GDB expects your runtime to expose a function called
`__jit_debug_register_code` and a global variable called
`__jit_debug_descriptor`. GDB automatically adds its own internal breakpoints
at this function, if it exists. Then, when you compile code, you call this
function from your runtime.

In slightly more detail:

1. Compile a function in your JIT compiler. This gives you a function name,
   maybe other metadata, an executable code address, and a code size
1. Generate an *entire* ELF/Mach-O/... object in-memory (!) for that one
   function, describing its name, code region, maybe other DWARF metadata such
   as line number maps
1. Write a `jit_code_entry` linked list node that points at your object
   ("symfile")
1. Link it into the `__jit_debug_descriptor` linked list
1. Call `__jit_debug_register_code`, which gives GDB control of the process so it can
   pick up the new function's metadata
1. Optionally, break into (or crash inside) one of your JITed functions
1. At some point, later, when your function gets GCed, unregister your code by
   editing the linked list and calling `__jit_debug_register_code` again

This is why you see compiler projects such as V8 including large swaths of code
just to make object files:

* [V8](https://github.com/v8/v8/blob/5668ed57de1c7c8dd5c3dc1598bf071e17d29c8c/src/diagnostics/gdb-jit.cc)
* [Cinder](https://github.com/facebookincubator/cinderx/blob/e6e925b20e6fa3fe1e100f147e1c8cd03076ebfb/cinderx/Jit/jit_gdb_support.cpp)
* [Zend PHP](https://github.com/zendtech/php-src/blob/f82e5b3abe1ff1d3ffc7954b0810bc584fd650a5/ext/opcache/jit/zend_jit_gdb.c#L473)
* [CoreCLR/.NET](https://github.com/dotnet/runtime/blob/3c040478f19e0f317790acab05dbe3ada9f52dc4/src/coreclr/vm/gdbjit.cpp)
* [QEMU](https://github.com/qemu/qemu/blob/942b0d378a1de9649085ad6db5306d5b8cef3591/tcg/tcg.c#L7064)
* [JavaScriptCore](https://github.com/WebKit/WebKit/blob/0afc2a867ab45651ac6c353c7b6ade5482b7bba7/Source/JavaScriptCore/jit/GdbJIT.cpp)
* [LuaJIT](https://github.com/LuaJIT/LuaJIT/blob/7152e15489d2077cd299ee23e3d51a4c599ab14f/src/lj_gdbjit.c)
* [ART](https://github.com/LineageOS/android_art/blob/8ce603e0c68899bdfbc9cd4c50dcc65bbf777982/runtime/jit/debugger_interface.cc#L187)
  * which looks like it does something smart about grouping the JIT code
    entries together (`RepackEntries`), but I'm not sure exactly what it does
* [HHVM](https://github.com/facebook/hhvm/blob/b1c47dcfbc574b508fd084f27ba4a06bcf4ba188/hphp/runtime/vm/debug/elfwriter.cpp#L622)
* [TomatoDotNet](https://github.com/TomatOrg/TomatoDotNet/blob/80266bb8dc0e7f0644f0638ecd98dfad4fb74427/src/dotnet/jit/gdb.c)
* [Jato JVM](https://github.com/jatovm/jato/blob/bb1c7d4fd987e016b2e0379182c4bfbb8c1c1a78/jit/elf.c#L164)
* [a minimal example](https://gist.github.com/yyny/4a012029b5889853c18b1efc19bb598e)
* [monoruby](https://github.com/sisshiki1969/jit-debug/blob/213c72512761f815fc0b067ce68ee0ae12962e2a/src/main.rs)
* [Mono](https://github.com/mono/mono/blob/0f53e9e151d92944cacab3e24ac359410c606df6/mono/mini/dwarfwriter.c)
* It looks like Dart [used to](https://github.com/dart-lang/sdk/commit/c4238c71da13d61ff32332058d371c5b2e92694b)
  have support for this but has since removed it

Because this is a huge hassle, GDB also has a newer interface that does not
require making an ELF/Mach-O/...+DWARF object.

## Custom debug info (the new interface)

This new interface requires writing a binary format of your choice. You make
the writer and you make the reader. Then, when you are in GDB, you load your
reader as a shared object.

Here are [some details from Sanjoy Das](https://pwparchive.wordpress.com/2011/11/20/new-jit-interface-for-gdb/).

Only a few runtimes implement this interface:

* [yk write](https://github.com/ykjit/yk/blob/755e533aa74ef5fa82a6586147727e23146b95fc/ykrt/src/compile/jitc_yk/gdb.rs#L216) <br />
  [yk read](https://github.com/ykjit/yk/blob/755e533aa74ef5fa82a6586147727e23146b95fc/ykrt/yk_gdb_plugin/yk_gdb_plugin.c#L22)
* [asmjit-utilities write](https://github.com/tetzank/asmjit-utilities/blob/2fdbb99f7e002df4f8d7aa97c29910743adfc991/gdb/gdbjit.cpp) <br />
  [asmjit-utilities read](https://github.com/tetzank/asmjit-utilities/blob/2fdbb99f7e002df4f8d7aa97c29910743adfc991/gdb/jit-reader/gdbjit-reader.c)
* [Erlang/OTP write](https://github.com/erlang/otp/blob/28a44634fb04b95ea666abb8aac7254e2c87ae05/erts/emulator/beam/jit/beam_jit_metadata.cpp#L123)
  * It looks like they do write their own custom debug format but I can't find
    the reader plugin
* [FEX write](https://github.com/FEX-Emu/FEX/blob/c8d72eabe589392b962bec94d002c5ffdb7381c2/FEXCore/Source/Interface/GDBJIT/GDBJIT.cpp#L110) <br />
  [FEX read](https://github.com/FEX-Emu/FEX/blob/c8d72eabe589392b962bec94d002c5ffdb7381c2/Source/Tools/FEXGDBReader/FEXGDBReader.cpp#L8)

I think it also requires at least the reader to proclaim it is GPL via the
macro `GDB_DECLARE_GPL_COMPATIBLE_READER`.

Since I wrote about the [perf map interface](/blog/jit-perf-map/) recently, I
have it on my mind. Why can't we use it in GDB?

## Adapting to the Linux perf interface

I suppose it would be possible to try and upstream a patch to GDB to support
the Linux perf map interface for JITs. In the meantime, maybe it is reasonable
to create a re-usable custom debug format:

* When registering code, write the address and name to `/tmp/perf-...` as you normally would
* Write the filename as the symfile
* Have the debug info reader just parse the perf map file

It would be less flexible than both the DWARF and custom readers support: it
would only be able to handle filename and code region. No embedding source code
for GDB to display in your debugger. But maybe that is okay for a partial
solution?

## The n-squared problem

## Moving GCs

V8 disables moving GC

ART treats the GDB JIT linked list as a weakref and periodically removes dead
code entries from it
