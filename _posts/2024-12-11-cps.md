---
title: Into CPS, never to return
layout: post
---

In the continuation-passing style (CPS) intermediate representation, there are
two rules: first, that function/operator arguments must always be *trivial*;
second, that function calls do not return. From this, a lot falls out.

In this post, we'll introduce CPS by building a simple (Plotkin) CPS transform
from a small Scheme-like language. We'll sketch some optimizations on the IR.
Then we'll look at a couple of the common ways to actually compile the IR for
execution.

## Mini-Scheme

We have integers: `5`

We have some operations on the integers: `(+ 1 2)`, `(< 3 4)` (returns 1 or 0)

We can bind variables: `(let ((x 1)) x)` / `(letrec ...)` ?

We can create single-parameter functions[^more-parameters]: `(lambda (x) (+ x 1))`

[^more-parameters]: It's a several-line change to the compiler to handle
    multiple parameters but for this post it's just noise so I leave it as an
    exercise.

We can call functions: `(f x)`

## How do I...?

We're going to implement a recursive function called `cps` incrementally,
starting with the easy forms of the language and working up from there. Many
people like implementing the compiler both in Scheme and for Scheme but I find
that all the quasiquoting makes everything fussier than it should be and
obscures the lesson, so we're doing it in Python.

This means we have a nice clear separation of code and data. Our Python code is
the compiler and we'll lean on Python lists for S-expressions. Here's what some
sample Scheme programs might look like as Python lists:

```python
5

["+", 1, 2]

["let", [["x", 1]], "x"]

["lambda", ["x"], ["+", "x", 1]]
```

Our `cps` function will take two arguments. The first argument, `exp`, is the
expression to compile. The second argument, `k`, is a *continuation*. We have
to do *something* with our values, but CPS requires that functions never
returns. So what do we do? Call another function, of course.

This means that the top-level invocation of `cps` will be passed some useful
top-level continuation like `print-to-screen` or `write-to-file`. All child
invocations of `cps` will be passed either that continuation, a manufactured
continuation, or a continuation variable.

```python
cps(["+", 1, 2], "$print-to-screen")
# ...or...
cps(["+", 1, 2], ["cont", ["v"], ...])
```

So a continuation is just another function. Kind of.

While you totally can generate real first-class functions for use as
continuations, it can often be useful to *partition* your CPS IR by separating
them. All real (user) functions will take a continuation as a last
parameter---for handing off their return values---whereas continuations do no
such thing. TODO: write more

For this reason we syntactically distinguish IR function forms `["fun", ["x",
"k"], ["k", "x"]]` from IR continuation forms `["cont", ["x"], ["k", "x"]]`.
Similarly, we distinguish function calls `["f", "x"]` from continuation calls
`["$ret", "k", "x"]` (where `$ret` is a special form known to the compiler).

Let's look at how we compile integers into CPS:

```python
def cps(exp, k):
    match exp:
        case int(_):
            return ["$ret", k, exp]
    raise NotImplementedError(type(exp))  # TODO

cps(5, "k")  # ["$ret", "k", 5]
```

Integers satisfy the *trivial* requirement. To be trivial is to not require
"significant" (more thatn constant-time) evaluation. `5`, for example, requires
none at all; return it. `(lambda (x) ...)` requires only a heap
allocation[^allocation].

[^allocation]: Yes, allocations might not be constant-time because of garbage
    collection and stuff. But there's no metaphorical recursive call to the
    imaginary `eval` function.

Variables are similar. We leave the variable names as-is for now, so we need
not keep an environment parameter around.

```python
def cps(exp, k):
    match exp:
        case int(_) | str(_):
            return ["$ret", k, exp]
    raise NotImplementedError(type(exp))  # TODO

cps("x", "k")  # ["$ret", "k", "x"]
```

Calls to primitive operators like `+` are our first real interesting case. We
have to both do recursive compilation of the arguments and also synthesize our
first continuations!

To evaluate an operand of `+`, which could be arbitrarily complex, we have to
make a recursive call to `cps`. Unlike normal compilers, this doesn't return a
value. Instead, you pass it a continuation (does the word "callback" help
here?) to do future work when that value has a name. To generate
compiler-internal names, we have a `gensym` function that isn't interesting and
returns unique strings.

```python
def gensym():
    ...

def cps(exp, k):
    match exp:
        case [op, x, y] if op in ["+", "-"]:
            vx = gensym()
            vy = gensym()
            return cps(x, ["cont", [vx],
                           cps(y, ["cont", [vy],
                                   [f"${op}", vx, vy, k]])])
    raise NotImplementedError(type(exp))  # TODO

cps(["+", 1, 2], "k")
# ["$ret", ["cont", ["v0"],
#            ["$ret", ["cont", ["v1"],
#                       ["$+", "v0", "v1", "k"]],
#                     2]],
#          1]

```

We also create a special form for the operator in our CPS IR that begins with
`$`. So `+` gets turned into `$+` and so on. This helps distinguish operator
invocations from function calls.

* not duplicating for `if`
* alphatisation gives you SSA-like

## Meta-continuations

* Olin Shivers and "functions rule the world" guy
* Hedgehog knows one great thing

## Optimizations

* optimizations on CPS

## To C, perhaps to XYZ

* Out of CPS?
  * to SSA (the paper)
  * trampolines
  * one big switch
  * cheney on the mta
