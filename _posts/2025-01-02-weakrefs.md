---
title: Weak references and garbage collectors
layout: post
---

From 2018 to 2021, I worked on a greenfield Python runtime called Skybison. One
of its major differences from CPython was that it used a moving garbage
collector (GC). This I understood in theory---I knew that it ran when the heap
filled up, knew we needed handles to update pointers in the runtime's code, had
read the [Moon paper](/assets/img/moon-gc.pdf) (PDF)---but the other day, I
wanted to implement weak references and couldn't immediately figure it out.
Skybison thankfully has a reasonably clear implementation. So now I'm writing
this post, mostly for myself, but maybe it will be useful to you as well.

In this post I'll give a brief overview of a garbage collector, a sample
"normal" object, and then show the special handling for weak references. I've
taken inspiration from the Skybison code, but it's possible other projects have
different approaches.

## Garbage collectors

While this post talks mostly about moving garbage collectors, I think the
weakref handling applies pretty cleanly to mark-sweep and other types of
stop-the-world GC as well. I don't know about reference counting or concurrent
GC, though.

> As an aside, if you have not been in the internals of a moving garbage
> collector before, I wholeheartedly recommend [Andy Wingo's post][wingo-gc].
> He's distilled the core ideas so well. Ever read a post that's so well
> written and concise that it takes your breath away? It's what brought the
> Moon paper from dream land into the real world for me.

[wingo-gc]: https://wingolog.org/archives/2022/12/10/a-simple-semi-space-collector

The important things to know about a garbage collector for this post are:

* It collects objects when they are dead
* Dead means that they have no pointers pointing to them
* "No pointers" means no non-weakref pointers
* A weakref is itself a type of object
* The weakref object might still be alive
* When a weakref's referent (thing it points to) dies, the `ref.referent` field
  should be cleared

Here is the core of Scrapscript's garbage collector. It's a very slightly
modified version of Andy's semispace GC. There are two phases, marked by
comments in the code: 1) scan the roots 2) incrementally copy over the object
graph (indirectly) pointed to by the roots. Everything not indirectly pointed
to is dead.

```c
void collect(struct gc_heap* heap) {
  flip(heap);
  // Scan the roots and copy them into newspace
  uintptr_t scan = heap->hp;
  for_each_root(heap, copy_to_newspace);
  // Now go copy the rest of the graph
  while (scan < heap->hp) {
    struct gc_obj* obj = (struct gc_obj*)scan;
    size_t size = heap_object_size(obj);
    uword end = scan + size;
    assert(is_size_aligned(end));
    for_each_field(obj, heap, copy_to_newspace);
    scan = end;
  }
}

void for_each_field(struct gc_obj* obj, struct gc_heap* heap, VisitFn visit) {
  switch (obj_tag(obj)) {
    case TAG_LIST:
      visit(&((struct list*)obj)->first, heap);
      visit(&((struct list*)obj)->rest, heap);
      break;
    // ...
    default:
      fprintf(stderr, "unknown tag: %u\n", obj_tag(obj));
      abort();
  }
}

void copy_to_newspace(struct gc_obj** pointer, struct gc_heap* heap) {
  struct gc_obj* from = *pointer;
  *pointer = is_forwarded(from) ? forwarded(from) : copy(heap, from);
}
```

> As an aside, using newspace as a queue like this (and, implict here, using
> forwarding pointers) is called Cheney copying after a technique described by
> CJ Cheney in his [1970 paper](/assets/img/cheney.pdf) (PDF). It's not
> important for this blog post, but it's worth knowing about.

Now, here's the problem. Say we were to add an empty case for weakrefs in
`for_each_field`.

```c
// ...
    case TAG_WEAKREF:
      // Don't visit the referent.
      break;
// ...
```

That's great and all---the weakref won't keep its referent alive---but there
are two problems:

1. If the referent dies, we have a dangling pointer into oldspace. We should
   instead clear the referent and have it point to some NULL-like sentinel
   object.
1. If the referent ends up staying alive, we have a dangling pointer to a
   forwarded object and need to fix it up.

Let's add one more step to fix both problems.

## Weak references

This is pseudocode. It's a sketch. The structs/casting/... don't compile as-is
in the Scrapscript runtime but that's because we do weird shenanigans with
pointers and that's unrelated to this article.

TODO: Make this self contained I guess and then link to the snippet.

```c
struct weakref {
  struct gc_obj HEAD;
  struct gc_obj* referent;
  struct gc_obj* link;
};

struct weakref* delayed_references = NULL;

void enqueue_weakref(struct weakref* ref) {
  ref->link = delayed_references;
  delayed_references = ref;
}

struct weakref *dequeue_weakref() {
  assert(delayed_references);
  struct weakref *result = delayed_references;
  delayed_references = result->link;
  // TODO(max): Is this necessary or can we leave the link field alone?
  result->link = your_sentinel_value;
  return result;
}

void collect(struct gc_heap* heap) {
  // ...
  while (scan < heap->hp) {
    struct gc_obj* obj = (struct gc_obj*)scan;
    size_t size = heap_object_size(obj);
    uword end = scan + size;
    assert(is_size_aligned(end));
    if (is_weakref(obj)) {
      // Enqueue to linked list
      enqueue_weakref((struct weakref*)obj);
    } else {
      for_each_field(obj, heap, copy_to_newspace);
    }
    scan = end;
  }
  // Update or clear all referents
  while (delayed_references != NULL) {
    struct weakref* ref = dequeue_weakref();
    struct gc_obj* referent = ref->referent;
    if (is_forwarding(ref->referent)) {
      ref->referent = forwarded(ref->referent);
    } else {
      ref->referent = your_sentinel_value;
    }
  }
}
```

Yeah, we have an extra field, but it makes weakrefs pay-as-you-go

## Other approaches

T3 compiler uses oldspace for data structures. See [Clark's 1976
paper](/assets/img/clark.pdf) (PDF) (Thanks, Taylor, for commenting on [Andy
Wingo's post][wingo-iterate])

[wingo-iterate]: https://wingolog.org/archives/2022/12/11/we-iterate-so-that-you-can-recurse

TODO link to https://github.com/tekknolagi/wingogc and mention bugs and update
handles
